<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stable Encryption Suite</title>

<style>
:root{
    --bg:#fff;
    --text:#000;
    --accent:#ffcc00;
}
body.dark{
    --bg:#000;
    --text:#fff;
}
body{
    background:var(--bg);
    color:var(--text);
    font-family:system-ui;
    max-width:900px;
    margin:40px auto;
}
.section{
    border:2px solid var(--text);
    padding:20px;
    margin-top:25px;
}
input{
    width:100%;
    padding:10px;
    border:2px solid var(--text);
    background:var(--bg);
    color:var(--text);
}
button{
    padding:10px 18px;
    border:2px solid var(--text);
    background:var(--accent);
    color:#000;
    margin-top:10px;
    cursor:pointer;
}
button:hover{
    background:var(--text);
    color:var(--accent);
}
.progress{
    height:8px;
    border:2px solid var(--text);
    margin-top:15px;
}
.bar{
    height:100%;
    width:0%;
    background:var(--accent);
}
</style>
</head>
<body>

<h2>Encryption Suite (Stable)</h2>
<button onclick="toggleMode()">Light/Dark</button>

<div class="section">
<label>パスワード</label>
<input type="password" id="password">
</div>

<div class="section">
<input type="file" id="fileInput">
<button onclick="encryptFile()">暗号化</button>
<button onclick="decryptFile()">復号</button>
<div class="progress"><div class="bar" id="bar"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/argon2-browser/dist/argon2-bundled.min.js"></script>
<script>

const MAGIC="KENC";
const VERSION=1;
const CHUNK_SIZE=4*1024*1024;

function toggleMode(){
    document.body.classList.toggle("dark");
}

function writeUint32(v){
    const b=new Uint8Array(4);
    new DataView(b.buffer).setUint32(0,v,true);
    return b;
}
function writeUint64(v){
    const b=new Uint8Array(8);
    new DataView(b.buffer).setBigUint64(0,BigInt(v),true);
    return b;
}
function readUint32(buf,off){
    return new DataView(buf.buffer).getUint32(off,true);
}
function readUint64(buf,off){
    return Number(new DataView(buf.buffer).getBigUint64(off,true));
}

async function deriveKey(password,salt,timeCost,memCost){
    const hash=await argon2.hash({
        pass:password,
        salt:salt,
        time:timeCost,
        mem:memCost,
        hashLen:32,
        parallelism:1,
        type:argon2.ArgonType.Argon2id
    });
    return crypto.subtle.importKey(
        "raw",
        hash.hash,
        {name:"AES-GCM"},
        false,
        ["encrypt","decrypt"]
    );
}

async function encryptFile(){
    const file=fileInput.files[0];
    if(!file)return alert("ファイル未選択");
    const pw=password.value;
    if(!pw)return alert("パスワード未入力");

    const salt=crypto.getRandomValues(new Uint8Array(16));
    const timeCost=3;
    const memCost=65536;

    const key=await deriveKey(pw,salt,timeCost,memCost);

    const headerParts=[
        new TextEncoder().encode(MAGIC),
        new Uint8Array([VERSION]),
        salt,
        new Uint8Array([timeCost]),
        writeUint32(memCost),
        writeUint64(file.size)
    ];

    let chunks=[...headerParts];

    const reader=file.stream().getReader();
    let processed=0;

    while(true){
        const {done,value}=await reader.read();
        if(done)break;

        const iv=crypto.getRandomValues(new Uint8Array(12));
        const encrypted=await crypto.subtle.encrypt(
            {name:"AES-GCM",iv:iv},
            key,
            value
        );

        const encArray=new Uint8Array(encrypted);

        chunks.push(writeUint32(value.length));
        chunks.push(iv);
        chunks.push(encArray);

        processed+=value.length;
        bar.style.width=((processed/file.size)*100)+"%";
    }

    const blob=new Blob(chunks);
    download(blob,file.name+".encrypted");
}

async function decryptFile(){
    const file=fileInput.files[0];
    if(!file)return alert("ファイル未選択");
    const pw=password.value;
    if(!pw)return alert("パスワード未入力");

    const buf=new Uint8Array(await file.arrayBuffer());
    let offset=0;

    if(new TextDecoder().decode(buf.slice(0,4))!==MAGIC)
        return alert("非対応形式");

    offset=4;
    const version=buf[offset++];
    const salt=buf.slice(offset,offset+16);
    offset+=16;
    const timeCost=buf[offset++];
    const memCost=readUint32(buf,offset);
    offset+=4;
    const originalSize=readUint64(buf,offset);
    offset+=8;

    const key=await deriveKey(pw,salt,timeCost,memCost);

    let output=[];
    let total=0;

    while(offset<buf.length){
        const chunkLen=readUint32(buf,offset);
        offset+=4;

        const iv=buf.slice(offset,offset+12);
        offset+=12;

        const encLen=chunkLen+16;
        const enc=buf.slice(offset,offset+encLen);
        offset+=encLen;

        try{
            const dec=await crypto.subtle.decrypt(
                {name:"AES-GCM",iv:iv},
                key,
                enc
            );
            output.push(new Uint8Array(dec));
            total+=dec.byteLength;
        }catch{
            return alert("復号失敗（鍵違いまたは破損）");
        }
    }

    if(total!==originalSize)
        return alert("サイズ不一致");

    const blob=new Blob(output);
    download(blob,file.name.replace(".encrypted",""));
}

function download(blob,name){
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=name;
    a.click();
}

</script>
</body>
</html>
